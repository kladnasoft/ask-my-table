# settings.py
from __future__ import annotations

import os
from typing import Dict, List, Any, Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel
from dotenv import dotenv_values, set_key, find_dotenv, load_dotenv

# Dynamically import "ask-my-table.py" as module alias `dc`
import importlib.util as _ilu, os as _os, sys as _sys
_p = _os.path.join(_os.path.dirname(__file__), "ask_my_table.py")
_sp = _ilu.spec_from_file_location("ask_my_table_mod_settings", _p)
if _sp is None or _sp.loader is None:
    raise RuntimeError("Failed to locate ask_my_table.py for import")
dc = _ilu.module_from_spec(_sp)  # type: ignore[assignment]
_sys.modules[_sp.name] = dc  # register for decorators/dataclasses
_sp.loader.exec_module(dc)  # type: ignore[attr-defined]

# Import hot_cache functions
from hot_cache import get_hot_cache_list, find_meta_by_fqn

router = APIRouter(tags=["settings"])

# ───────────────────────── editable keys ─────────────────────────
EDITABLE_KEYS: List[str] = [
    # Provider selection
    "AI_PROVIDER", "DB_MODE",

    # Azure OpenAI
    "AZURE_OPENAI_ENDPOINT", "AZURE_OPENAI_DEPLOYMENT",
    "AZURE_OPENAI_API_VERSION", "AZURE_OPENAI_API_KEY",

    # OpenAI (for compatibility)
    "OPENAI_API_KEY", "OPENAI_METABUILDER_ID",

    # Metaschema + limits
    "METASCHEMA_DIR",
    "QUERY_MAX_ROWS", "PLAN_MAX_TABLES", "PLAN_MAX_COLS_PER_TABLE",
    "FILTER_PROBE_TOPN", "SQL_MAX_RETRIES",
]

SECRET_KEYS = {
    "AZURE_OPENAI_API_KEY",
    "OPENAI_API_KEY", "OPENAI_METABUILDER_ID",
}

_DOTENV_PATH = find_dotenv(usecwd=True) or ".env"

# ───────────────────────── helpers ─────────────────────────
def _env_map() -> Dict[str, str]:
    try:
        return {k: str(v) for k, v in (dotenv_values(_DOTENV_PATH) or {}).items()}
    except Exception:
        return {}

def _effective_for_key(key: str) -> Optional[str]:
    cfg = dc.CONFIG
    mapping = {
        "AI_PROVIDER": cfg.ai_provider,
        "DB_MODE": cfg.db_mode,

        "AZURE_OPENAI_ENDPOINT": cfg.azure_openai_endpoint,
        "AZURE_OPENAI_DEPLOYMENT": cfg.azure_openai_deployment,
        "AZURE_OPENAI_API_VERSION": cfg.azure_openai_api_version,
        "AZURE_OPENAI_API_KEY": cfg.azure_openai_api_key,

        "OPENAI_API_KEY": cfg.openai_api_key,
        "OPENAI_METABUILDER_ID": cfg.openai_metabuilder_id,

        "METASCHEMA_DIR": cfg.metaschema_dir,

        "QUERY_MAX_ROWS": str(cfg.query_max_rows),
        "PLAN_MAX_TABLES": str(cfg.max_tables_plan),
        "PLAN_MAX_COLS_PER_TABLE": str(cfg.max_cols_per_table_plan),
        "FILTER_PROBE_TOPN": str(cfg.filter_probe_topn),
        "SQL_MAX_RETRIES": str(cfg.sql_max_retries),
    }
    return mapping.get(key)

def _apply_reload() -> Dict[str, Any]:
    load_dotenv(override=True)
    dc.CONFIG = dc.load_config()  # type: ignore[attr-defined]
    dc.METASCHEMA_BY_FQN, dc.ALLOWED_TABLES = dc.load_metaschema(dc.CONFIG.metaschema_dir)  # type: ignore[attr-defined]
    return dc.get_public_status()  # type: ignore[attr-defined]

# ───────────────────────── models ─────────────────────────
class SettingsItem(BaseModel):
    key: str
    value: Optional[str] = None
    effective: Optional[str] = None
    secret: bool = False

class SettingsPayload(BaseModel):
    updates: List[SettingsItem]
    apply: bool = True

# ───────────────────────── routes ─────────────────────────
@router.get("/settings/config")
def get_config() -> Dict[str, Any]:
    env_file_vals = _env_map()
    items: List[SettingsItem] = []
    for key in EDITABLE_KEYS:
        items.append(SettingsItem(
            key=key,
            value=env_file_vals.get(key),
            effective=_effective_for_key(key),
            secret=(key in SECRET_KEYS),
        ))
    return {
        "dotenv_path": _DOTENV_PATH,
        "items": [i.model_dump() for i in items],
    }

@router.post("/settings/config")
def post_config(payload: SettingsPayload) -> Dict[str, Any]:
    # Ensure .env exists
    if not os.path.exists(_DOTENV_PATH):
        try:
            with open(_DOTENV_PATH, "w", encoding="utf-8") as f:
                f.write("# Generated by settings UI\n")
        except Exception as exc:
            raise HTTPException(status_code=500, detail=f"Cannot create .env: {exc}")

    # Persist updates to .env (and process env)
    for it in payload.updates:
        if it.key not in EDITABLE_KEYS:
            raise HTTPException(status_code=400, detail=f"Key not editable: {it.key}")
        try:
            set_key(_DOTENV_PATH, it.key, "" if it.value is None else str(it.value), quote_mode="never")
            if it.value is None:
                os.environ.pop(it.key, None)
            else:
                os.environ[it.key] = str(it.value)
        except Exception as exc:
            raise HTTPException(status_code=500, detail=f"Failed to update {it.key}: {exc}")

    status: Dict[str, Any] = {}
    if payload.apply:
        status = _apply_reload()

    return {
        "ok": True,
        "applied": payload.apply,
        "status": status,
    }

@router.get("/settings/cache")
def get_cache() -> Dict[str, Any]:
    tables = get_hot_cache_list(dc.METASCHEMA_BY_FQN)  # type: ignore[attr-defined]
    return {
        "metaschema_dir": dc.CONFIG.metaschema_dir,  # type: ignore[attr-defined]
        "count": len(tables),
        "tables": tables,
    }

@router.post("/settings/cache/reload")
def reload_cache() -> Dict[str, Any]:
    dc.METASCHEMA_BY_FQN, dc.ALLOWED_TABLES = dc.load_metaschema(dc.CONFIG.metaschema_dir)  # type: ignore[attr-defined]
    return get_cache()

# NEW: fetch a single hot-cache item's content (raw JSON meta)
@router.get("/settings/cache/item")
def get_cache_item(fqn: str = Query(..., description="schema.table or metaschema key")) -> Dict[str, Any]:
    meta = find_meta_by_fqn(dc.METASCHEMA_BY_FQN, fqn)  # type: ignore[attr-defined]
    if not meta:
        raise HTTPException(status_code=404, detail=f"Cache item not found: {fqn}")
    # Provide a little helpful envelope
    ident = meta.get("identity", {})
    return {
        "fqn": fqn,
        "schema": ident.get("schema"),
        "table": ident.get("table"),
        "meta": meta,
    }